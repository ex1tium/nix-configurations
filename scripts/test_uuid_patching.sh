#!/usr/bin/env bash

# Test script for UUID patching functionality
set -euo pipefail

# Simple logging functions for testing
echo_info() { echo "ℹ️  $*"; }
echo_success() { echo "✅ $*"; }
echo_error() { echo "❌ $*"; }

# Create a test hardware configuration
create_test_hardware_config() {
  local test_file="$1"
  cat > "$test_file" << 'EOF'
# Do not modify this file!  It was generated by 'nixos-generate-config'
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports =
    [ (modulesPath + "/installer/scan/not-detected.nix")
    ];

  boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "nvme" "usb_storage" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/old-root-uuid-1234";
      fsType = "btrfs";
      options = [ "subvol=root" "compress=zstd" ];
    };

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/old-esp-uuid-5678";
      fsType = "vfat";
      options = [ "fmask=0022" "dmask=0022" ];
    };

  fileSystems."/home" =
    { device = "/dev/disk/by-uuid/old-root-uuid-1234";
      fsType = "btrfs";
      options = [ "subvol=home" "compress=zstd" ];
    };

  fileSystems."/nix" =
    { device = "/dev/disk/by-uuid/old-root-uuid-1234";
      fsType = "btrfs";
      options = [ "subvol=nix" "compress=zstd" "noatime" ];
    };

  swapDevices = [ ];

  networking.useDHCP = lib.mkDefault true;
  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
EOF
}

# Test the UUID patching function
test_uuid_patching() {
  echo "🧪 Testing UUID patching functionality..."
  
  # Create test file
  local test_file="/tmp/test-hardware-config.nix"
  create_test_hardware_config "$test_file"
  
  echo "📄 Original hardware config created"
  
  # Define new UUIDs
  local new_root_uuid="new-root-uuid-abcd"
  local new_esp_uuid="new-esp-uuid-efgh"
  
  # Create fake UUID symlinks for validation
  sudo mkdir -p /dev/disk/by-uuid/
  sudo touch "/dev/disk/by-uuid/$new_root_uuid"
  sudo touch "/dev/disk/by-uuid/$new_esp_uuid"
  
  echo "🔗 Created test UUID symlinks"
  
  # Source the patch function (simplified version for testing)
  patch_hardware_config_uuids() {
    local hw_config="$1"
    local root_uuid="$2"
    local esp_uuid="$3"
    
    echo "🔧 Patching UUIDs in $hw_config"
    echo "   Root UUID: $root_uuid"
    echo "   ESP UUID: $esp_uuid"
    
    # Create backup
    cp "$hw_config" "${hw_config}.backup"
    
    # Simple sed-based patching for testing
    if [[ -n $root_uuid ]]; then
      sed -i "s/old-root-uuid-1234/$root_uuid/g" "$hw_config"
      echo "✅ Patched root UUID"
    fi
    
    if [[ -n $esp_uuid ]]; then
      sed -i "s/old-esp-uuid-5678/$esp_uuid/g" "$hw_config"
      echo "✅ Patched ESP UUID"
    fi
    
    return 0
  }
  
  # Test the patching
  if patch_hardware_config_uuids "$test_file" "$new_root_uuid" "$new_esp_uuid"; then
    echo "✅ UUID patching completed successfully"
    
    # Verify the changes
    if grep -q "$new_root_uuid" "$test_file" && grep -q "$new_esp_uuid" "$test_file"; then
      echo "✅ UUIDs were correctly updated in the file"
      
      # Show the changes
      echo "📋 Updated hardware config preview:"
      grep -A 2 -B 2 "by-uuid" "$test_file" | head -10
    else
      echo "❌ UUIDs were not found in the updated file"
      return 1
    fi
  else
    echo "❌ UUID patching failed"
    return 1
  fi
  
  # Cleanup
  rm -f "$test_file" "${test_file}.backup"
  sudo rm -f "/dev/disk/by-uuid/$new_root_uuid" "/dev/disk/by-uuid/$new_esp_uuid"
  
  echo "🎉 UUID patching test completed successfully!"
}

# Run the test
test_uuid_patching
