#!/usr/bin/env bash
# Fix current installation that has wrong hardware configuration

set -euo pipefail

# Load common functions
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)
# shellcheck source=lib/common.sh
source "$SCRIPT_DIR/lib/common.sh"

main() {
    print_box "$CYAN" "ðŸ”§ Fix Current Installation ðŸ”§" \
        "${WHITE}This script will fix the hardware configuration" \
        "${YELLOW}for an installation that has BTRFS but ext4 config"
    echo

    # Check if we're in the right context (booted from live environment)
    if [[ ! -d /mnt ]]; then
        log_error "This script should be run from a NixOS live environment"
        log_info "Please boot from NixOS live USB/ISO and run this script"
        exit 1
    fi

    # Detect the root device
    log_info "Detecting installation..."
    
    # Try to find BTRFS partitions
    local btrfs_devices
    mapfile -t btrfs_devices < <(lsblk -f -n -o NAME,FSTYPE | grep btrfs | awk '{print "/dev/"$1}')
    
    if (( ${#btrfs_devices[@]} == 0 )); then
        log_error "No BTRFS filesystems found"
        exit 1
    fi
    
    log_info "Found BTRFS devices: ${btrfs_devices[*]}"
    
    # Use the first BTRFS device (assuming it's the root)
    local root_device="${btrfs_devices[0]}"
    log_info "Using root device: $root_device"
    
    # Mount the BTRFS filesystem
    log_info "Mounting BTRFS filesystem..."
    
    # First mount the root subvolume
    if ! mount -o subvol=@root,compress=zstd "$root_device" /mnt; then
        log_error "Failed to mount @root subvolume"
        log_info "Trying to mount without subvolume options..."
        if ! mount "$root_device" /mnt; then
            log_error "Failed to mount root device"
            exit 1
        fi
    fi
    
    # Create mount points and mount other subvolumes
    mkdir -p /mnt/{home,nix,.snapshots,boot}
    
    mount -o subvol=@home,compress=zstd "$root_device" /mnt/home 2>/dev/null || log_warn "Could not mount @home"
    mount -o subvol=@nix,compress=zstd "$root_device" /mnt/nix 2>/dev/null || log_warn "Could not mount @nix"
    mount -o subvol=@snapshots,compress=zstd "$root_device" /mnt/.snapshots 2>/dev/null || log_warn "Could not mount @snapshots"
    
    # Try to mount boot partition
    local boot_devices
    mapfile -t boot_devices < <(lsblk -f -n -o NAME,FSTYPE | grep vfat | awk '{print "/dev/"$1}')
    
    if (( ${#boot_devices[@]} > 0 )); then
        local boot_device="${boot_devices[0]}"
        log_info "Mounting boot device: $boot_device"
        mount "$boot_device" /mnt/boot 2>/dev/null || log_warn "Could not mount boot partition"
    fi
    
    # Check if hardware config exists
    local hw_config="/mnt/etc/nixos/hardware-configuration.nix"
    if [[ ! -f "$hw_config" ]]; then
        log_error "Hardware configuration not found at $hw_config"
        log_info "The installation may be incomplete or corrupted"
        exit 1
    fi
    
    log_info "Current hardware configuration:"
    grep -A 3 -B 1 'fileSystems\."/"' "$hw_config" || log_warn "Could not find root filesystem config"
    
    # Check if it needs fixing
    if grep -q 'fsType = "btrfs"' "$hw_config" && grep -q "subvol=@root" "$hw_config"; then
        log_success "Hardware configuration already looks correct!"
        log_info "The boot issue may be caused by something else"
        exit 0
    fi
    
    log_warn "Hardware configuration needs fixing..."
    
    # Get UUIDs
    local root_uuid esp_uuid
    root_uuid=$(blkid -s UUID -o value "$root_device")
    
    if [[ -n ${boot_devices[0]:-} ]]; then
        esp_uuid=$(blkid -s UUID -o value "${boot_devices[0]}")
    else
        esp_uuid="UNKNOWN"
        log_warn "Could not determine ESP UUID"
    fi
    
    log_info "Root UUID: $root_uuid"
    log_info "ESP UUID: $esp_uuid"
    
    # Backup original
    cp "$hw_config" "${hw_config}.backup.$(date +%s)"
    log_info "Backed up original hardware config"
    
    # Create corrected hardware config
    log_info "Creating corrected hardware configuration..."
    
    cat > "${hw_config}.new" << EOF
# Do not modify this file!  It was generated by 'nixos-generate-config'
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, modulesPath, ... }:

{
  imports = [ (modulesPath + "/installer/scan/not-detected.nix") ];

  boot.initrd.availableKernelModules = [ "ahci" "xhci_pci" "virtio_pci" "sr_mod" "virtio_blk" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ "kvm-intel" ];
  boot.extraModulePackages = [ ];

  fileSystems."/" = {
    device = "/dev/disk/by-uuid/$root_uuid";
    fsType = "btrfs";
    options = [ "subvol=@root" "compress=zstd" ];
  };

  fileSystems."/home" = {
    device = "/dev/disk/by-uuid/$root_uuid";
    fsType = "btrfs";
    options = [ "subvol=@home" "compress=zstd" ];
  };

  fileSystems."/nix" = {
    device = "/dev/disk/by-uuid/$root_uuid";
    fsType = "btrfs";
    options = [ "subvol=@nix" "compress=zstd" ];
  };

  fileSystems."/.snapshots" = {
    device = "/dev/disk/by-uuid/$root_uuid";
    fsType = "btrfs";
    options = [ "subvol=@snapshots" "compress=zstd" ];
  };

  fileSystems."/boot" = {
    device = "/dev/disk/by-uuid/$esp_uuid";
    fsType = "vfat";
    options = [ "fmask=0022" "dmask=0022" ];
  };

  swapDevices = [ ];

  networking.useDHCP = lib.mkDefault true;
  nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
EOF

    # Replace the hardware config
    mv "${hw_config}.new" "$hw_config"
    
    log_success "Hardware configuration fixed!"
    
    # Rebuild the system
    log_info "Rebuilding system configuration..."
    if nixos-rebuild boot --root /mnt; then
        log_success "System rebuilt successfully!"
        log_info "You can now reboot and the system should boot correctly"
    else
        log_error "Failed to rebuild system"
        log_info "You may need to check the configuration manually"
        exit 1
    fi
    
    # Cleanup
    log_info "Cleaning up..."
    umount -R /mnt 2>/dev/null || log_warn "Some filesystems could not be unmounted"
    
    log_success "Fix completed! You can now reboot the system."
}

main "$@"
